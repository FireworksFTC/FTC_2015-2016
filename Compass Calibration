package com.qualcomm.ftcrobotcontroller.opmodes;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.CompassSensor;
import com.qualcomm.robotcore.hardware.UltrasonicSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.LightSensor;

public class CompassCalibration extends OpMode {
  CompassSensor compass;
  UltrasonicSensor ultrasonicSensor;
  DcMotor motorRight;
  DcMotor motorLeft;
  Servo servo1, servo2;
  LightSensor lSensorR, lSensorL;

  double degree;
  double leftPower;
  double rightPower;
  boolean turned;
  boolean inFront;
  boolean reachedBeacon;
  boolean isDoorUp;
  double lightStartTime;

  int totalLightL, avgLightL = 0, countL;
  int totalLightR, avgLightR = 0, countR;
  boolean isScanningForLight;
  String desiredLight = "red";

  final double MEASURING_TIME = 2.0;

  @Override
  public void init() {
    compass = hardwareMap.compassSensor.get("compass");
    ultrasonicSensor = hardwareMap.ultrasonicSensor.get("ultrasonic_sensor");
    motorRight = hardwareMap.dcMotor.get("motor_2");
    motorLeft = hardwareMap.dcMotor.get("motor_1");
    motorRight.setDirection(DcMotor.Direction.REVERSE);
    servo1 = hardwareMap.servo.get("servo_1");
    servo2 = hardwareMap.servo.get("servo_2");
    servo1.setDirection(Servo.Direction.REVERSE);
    lSensorL = hardwareMap.lightSensor.get("light_sensor_left");
    lSensorR = hardwareMap.lightSensor.get("light_sensor_right");

    isScanningForLight = false;
    turned = false;
    inFront = false;
    reachedBeacon = false;
    isDoorUp = false;
  }

  @Override
  public void init_loop() {

  }

  @Override
  public void loop() {
    degree = compass.getDirection(); //get degree value from compass sensor
    telemetry.addData("Degree", "Degree of robot" + degree); //printing the degree of robot
    if (this.time < 2) { //if less than 2 seconds then go on low power in both motors
      rightPower = 0.15;
      leftPower = 0.15;

    } else if (degree > 180 && !turned) { // if time more than or equal to 2 seconds then if robot direction is more than 180 degrees then turn left
      rightPower = -0.15;
      leftPower = 0.15;

    } else if (degree < 45 && !turned) { // if robot direction is less than 45 degrees then turn left
      rightPower = -0.15;
      leftPower = 0.15;
    } else if (degree >= 45 && degree < 180 && !turned) { //if robot direction is more than 45 degrees and less than 180 degrees then go forward
      rightPower = 0.15;
      leftPower = 0.15;
      turned = true;
    } else if (this.time > 3 && this.time < 6.5 && turned) { //if time between 3 and 6.5 sec then go forward
      rightPower = 0.15;
      leftPower = 0.15;
    } else if (this.time > 6.5 && this.time <7.2) {
      rightPower = -0.15;
      leftPower = 0.15;
      inFront = true;
    } else if (inFront == true && !reachedBeacon && ultrasonicSensor.getUltrasonicLevel()>5){
      rightPower = 0.10;
      leftPower = 0.10;
      telemetry.addData("ultrasonicDistance",ultrasonicSensor.getUltrasonicLevel());
      reachedBeacon = true;
    }else if (this.time >=10 && this.time <12 && reachedBeacon){
      rightPower = -0.20;
      leftPower = -0.20;
    }else if (this.time >=12 && this.time <12.7 && reachedBeacon){
      rightPower =-0.15;
      leftPower =0.15;
    }else if (this.time >=12.7 && this.time <20 && reachedBeacon){
      rightPower =0.35;
      leftPower =0.35;
    }
    else {
      rightPower = 0;
      leftPower = 0;
    }


    motorRight.setPower(rightPower);
    motorLeft.setPower(leftPower);

  }

  //makes the door come up
  void doorUp(){
    servo1.setPosition(0.53);
    servo2.setPosition(0.53);
  }

  //makes the door go down
  void doorDown(){
    servo1.setPosition(0.46);
    servo2.setPosition(0.46);
  }

  //usage of this method:
  /*
      while (pushLight() < 0){
        ; //wait for scanning to end
      }
   */
  int pushLight(){
    if(isScanningForLight == false) {
      isScanningForLight = true;
      lightStartTime = time;
      countR = 0;
      totalLightR = 0;
      countL = 0;
      totalLightL = 0;
    }

    if(isScanningForLight == true){
      totalLightR += lSensorR.getLightDetectedRaw();
      totalLightL += lSensorL.getLightDetectedRaw();
      countR++;
      countL++;

      if (time > lightStartTime+MEASURING_TIME){
        isScanningForLight = false;
        avgLightR = totalLightR/countR;
        avgLightL = (totalLightL/countL) - 20; //-20 for calibration

        if (desiredLight.toLowerCase().equals("red")){
          if(avgLightL > avgLightR){ //the red light is on the right

            //add how to press the button with a finger

          }
          if (avgLightL < avgLightR){ //the red light is on the left

            //add how to press the button with a finger

          }
        }

        if (desiredLight.toLowerCase().equals("blue")){
          if(avgLightL < avgLightR){ //the blue light is on the right

            //add how to press the button with a finger

          }
          if (avgLightL > avgLightR){ //the blue light is on the left

            //add how to press the button with a finger

          }
        }
       
        if (avgLightL == avgLightR){ //no decision made

          //add how to deal with failure

        }
      }
    }
  }
}
